# Импорт необходимых библиотек
import tkinter as tk  # импортирует библиотеку tkinter для создания графического интерфейса
import numpy as np  # импортирует библиотеку numpy для математических операций с массивами
import matplotlib.pyplot as plt  # импортирует библиотеку matplotlib для построения графиков
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg  # импортирует класс для встраивания графиков в tkinter

# Создаем главное окно приложения
root = tk.Tk()  # создает главное окно приложения - корневой элемент интерфейса
root.title("Сложение гармонических колебаний | Работа Павла Юнкер")  # устанавливает заголовок окна
root.geometry("1000x800")  # устанавливает размер окна 1000x800 пикселей

# Создаем списки для хранения элементов управления
amp_entries = []  # создает пустой список для хранения полей ввода амплитуд
freq_entries = []  # создает пустой список для хранения полей ввода частот

# Функция для расчета и построения графиков
def plot_oscillations():
    """
    Функция для расчета суммы гармонических колебаний и построения графиков
    """
    # Очищаем предыдущие графики
    ax1.clear()  # очищает первую область графика от предыдущих данных
    ax2.clear()  # очищает вторую область графика от предыдущих данных
    
    # Создаем массив времени от 0 до 2 секунд с шагом 0.001
    t = np.arange(0, 2, 0.001)  # создает массив моментов времени от 0 до 2 секунд с очень мелким шагом для плавности графика
    
    # Инициализируем массив для результирующего колебания нулями
    result = np.zeros_like(t)  # создает массив такой же длины как t, заполненный нулями, для накопления суммы колебаний
    
    # Создаем список для хранения отдельных колебаний
    oscillations = []  # создает пустой список для хранения массивов каждого отдельного колебания
    
    # Проходим по всем пяти колебаниям
    for i in range(5):  # цикл для обработки всех 5 гармонических колебаний
        try:
            # Получаем амплитуду и частоту для i-го колебания
            amplitude = float(amp_entries[i].get())  # получает значение амплитуды из i-го поля ввода и преобразует в число
            frequency = float(freq_entries[i].get())  # получает значение частоты из i-го поля ввода и преобразует в число
            
            # Вычисляем i-е гармоническое колебание
            oscillation = amplitude * np.sin(2 * np.pi * frequency * t)  # вычисляет гармоническое колебание по формуле y = A*sin(2πft)
            
            # Добавляем колебание в список
            oscillations.append(oscillation)  # добавляет вычисленное колебание в список отдельных колебаний
            
            # Добавляем колебание к результирующему
            result += oscillation  # прибавляет текущее колебание к общему результату (сумме всех колебаний)
            
        except ValueError:  # обрабатывает случай, если пользователь ввел нечисловые данные
            print(f"Ошибка в данных для колебания {i+1}")  # выводит сообщение об ошибке в консоль
    
    # Построение графиков на первом subplot
    # Строим отдельные колебания
    colors = ['blue', 'red', 'green', 'orange', 'purple']  # создает список цветов для разных колебаний
    labels = ['Колебание 1', 'Колебание 2', 'Колебание 3', 'Колебание 4', 'Колебание 5']  # создает список подписей для легенды
    
    for i, oscillation in enumerate(oscillations):  # цикл по всем отдельным колебаниям с получением индекса и значения
        ax1.plot(t, oscillation, color=colors[i], label=labels[i], linewidth=1.5, alpha=0.7)  # строит график i-го колебания с заданным цветом и подписью
    
    # Настраиваем первый график
    ax1.set_title('Отдельные гармонические колебания')  # устанавливает заголовок для первого графика
    ax1.set_xlabel('Время (с)')  # добавляет подпись к оси X первого графика
    ax1.set_ylabel('Амплитуда')  # добавляет подпись к оси Y первого графика
    ax1.grid(True, linestyle='--', alpha=0.5)  # добавляет сетку на первый график
    ax1.legend()  # отображает легенду на первом графике
    
    # Построение графика суммы колебаний на втором subplot
    ax2.plot(t, result, color='black', linewidth=2, label='Сумма колебаний')  # строит график результирующего колебания черной толстой линией
    
    # Настраиваем второй график
    ax2.set_title('Результирующее колебание (сумма)')  # устанавливает заголовок для второго графика
    ax2.set_xlabel('Время (с)')  # добавляет подпись к оси X второго графика
    ax2.set_ylabel('Амплитуда')  # добавляет подпись к оси Y второго графика
    ax2.grid(True, linestyle='--', alpha=0.5)  # добавляет сетку на второй график
    ax2.legend()  # отображает легенду на втором графике
    
    # Автоматически подбираем масштаб для обоих графиков
    ax1.autoscale_view()  # автоматически настраивает масштаб осей первого графика
    ax2.autoscale_view()  # автоматически настраивает масштаб осей второго графика
    
    # Обновляем холст с графиками
    canvas.draw()  # перерисовывает холст чтобы отобразить все изменения

# Функция для сброса параметров к значениям по умолчанию
def reset_parameters():
    """
    Функция для сброса всех параметров колебаний к значениям по умолчанию
    """
    # Значения по умолчанию для амплитуд и частот
    default_amps = [1.0, 0.5, 0.3, 0.2, 0.1]  # создает список амплитуд по умолчанию (убывающие значения)
    default_freqs = [1.0, 2.0, 3.0, 4.0, 5.0]  # создает список частот по умолчанию (возрастающие значения)
    
    for i in range(5):  # цикл по всем 5 колебаниям
        amp_entries[i].delete(0, tk.END)  # очищает i-е поле ввода амплитуды
        amp_entries[i].insert(0, str(default_amps[i]))  # вставляет i-е значение амплитуды по умолчанию
        
        freq_entries[i].delete(0, tk.END)  # очищает i-е поле ввода частоты
        freq_entries[i].insert(0, str(default_freqs[i]))  # вставляет i-е значение частоты по умолчанию
    
    # Перестраиваем графики с новыми параметрами
    plot_oscillations()  # вызывает функцию построения графиков с параметрами по умолчанию

# Создаем основной фрейм для элементов управления
control_frame = tk.Frame(root)  # создает контейнер для размещения элементов управления
control_frame.pack(pady=10)  # размещает контейнер в окне с вертикальными отступами

# Создаем заголовок для таблицы параметров
header_label = tk.Label(control_frame, text="Параметры гармонических колебаний", font=('Arial', 12, 'bold'))  # создает заголовок с крупным шрифтом
header_label.grid(row=0, column=0, columnspan=3, pady=10)  # размещает заголовок в сетке, объединяя три столбца

# Создаем заголовки столбцов
amp_header = tk.Label(control_frame, text="Амплитуда", font=('Arial', 10, 'bold'))  # создает заголовок столбца амплитуд
amp_header.grid(row=1, column=1, padx=5, pady=5)  # размещает заголовок амплитуд в сетке

freq_header = tk.Label(control_frame, text="Частота (Гц)", font=('Arial', 10, 'bold'))  # создает заголовок столбца частот
freq_header.grid(row=1, column=2, padx=5, pady=5)  # размещает заголовок частот в сетке

# Создаем поля ввода для 5 колебаний
for i in range(5):  # цикл для создания элементов управления для всех 5 колебаний
    # Создаем метку для номера колебания
    label = tk.Label(control_frame, text=f"Колебание {i+1}:")  # создает метку с номером колебания
    label.grid(row=i+2, column=0, padx=5, pady=2, sticky='e')  # размещает метку в сетке с выравниванием по правому краю
    
    # Создаем поле ввода для амплитуды
    amp_entry = tk.Entry(control_frame, width=10)  # создает поле ввода амплитуды шириной 10 символов
    amp_entry.grid(row=i+2, column=1, padx=5, pady=2)  # размещает поле ввода амплитуды в сетке
    amp_entries.append(amp_entry)  # добавляет созданное поле ввода в список амплитуд
    
    # Создаем поле ввода для частоты
    freq_entry = tk.Entry(control_frame, width=10)  # создает поле ввода частоты шириной 10 символов
    freq_entry.grid(row=i+2, column=2, padx=5, pady=2)  # размещает поле ввода частоты в сетке
    freq_entries.append(freq_entry)  # добавляет созданное поле ввода в список частот

# Создаем фрейм для кнопок
button_frame = tk.Frame(root)  # создает отдельный контейнер для кнопок
button_frame.pack(pady=10)  # размещает контейнер с кнопками в окне

# Создаем кнопку для построения графиков
plot_button = tk.Button(button_frame, text="Построить графики", command=plot_oscillations, 
                       bg="lightgreen", width=20, height=2)  # создает кнопку с зеленым фоном для построения графиков
plot_button.pack(side=tk.LEFT, padx=10)  # размещает кнопку слева в контейнере с отступами

# Создаем кнопку для сброса параметров
reset_button = tk.Button(button_frame, text="Сбросить параметры", command=reset_parameters,
                        bg="lightcoral", width=20, height=2)  # создает кнопку с красным фоном для сброса параметров
reset_button.pack(side=tk.LEFT, padx=10)  # размещает кнопку слева рядом с предыдущей

# Создаем фигуру matplotlib с двумя subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))  # создает фигуру с двумя графиками расположенными вертикально
fig.tight_layout(pad=5.0)  # автоматически регулирует отступы между графиками

# Создаем холст для встраивания графиков в tkinter
canvas = FigureCanvasTkAgg(fig, master=root)  # создает холст для отображения matplotlib графиков в tkinter
canvas_widget = canvas.get_tk_widget()  # получает tkinter-виджет из холста
canvas_widget.pack(pady=10)  # размещает виджет с графиками в окне

# Устанавливаем параметры по умолчанию и строим начальные графики
reset_parameters()  # вызывает функцию сброса параметров, которая устанавливает значения по умолчанию и строит графики

# Запускаем главный цикл обработки событий
root.mainloop()  # запускает бесконечный цикл обработки событий tkinter (программа работает пока окно не закрыто)