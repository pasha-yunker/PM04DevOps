# Импорт необходимых библиотек
import tkinter as tk  # импортирует библиотеку tkinter для создания графического интерфейса
from tkinter import ttk  # импортирует модуль ttk для стилизованных виджетов

# Создаем главное окно приложения
root = tk.Tk()  # создает главное окно приложения
root.title("Коды символов в разных системах кодирования | Работа Павла Юнкер")  # устанавливает заголовок окна
root.geometry("800x670")  # устанавливает размер окна 800x600 пикселей

# Создаем функцию для получения кодов символа в разных кодировках
def get_char_codes(char):
    """
    Функция для получения кодов символа в разных системах кодирования
    """
    codes = {}  # создает пустой словарь для хранения кодов в разных кодировках
    
    try:
        # Получаем Unicode код символа (UTF-32)
        codes['Unicode (UTF-32)'] = ord(char)  # функция ord() возвращает числовое представление символа в Unicode
    except:
        codes['Unicode (UTF-32)'] = 'N/A'  # если возникла ошибка, устанавливаем 'N/A'
    
    try:
        # Пытаемся получить код в ASCII
        codes['ASCII'] = ascii_codes.get(char, 'N/A')  # пытаемся найти символ в словаре ASCII кодов
    except:
        codes['ASCII'] = 'N/A'  # если возникла ошибка, устанавливаем 'N/A'
    
    try:
        # Пытаемся закодировать в Windows-1251 (CP1251)
        encoded = char.encode('windows-1251')  # кодируем символ в кодировку Windows-1251
        codes['Windows-1251 (CP1251)'] = encoded[0]  # берем первый байт (для однобайтовых кодировок)
    except:
        codes['Windows-1251 (CP1251)'] = 'N/A'  # если символ не поддерживается в этой кодировке
    
    try:
        # Пытаемся закодировать в CP866 (DOS Russian)
        encoded = char.encode('cp866')  # кодируем символ в кодировку CP866
        codes['CP866 (DOS)'] = encoded[0]  # берем первый байт
    except:
        codes['CP866 (DOS)'] = 'N/A'  # если символ не поддерживается в этой кодировке
    
    try:
        # Получаем код в UTF-8
        encoded = char.encode('utf-8')  # кодируем символ в UTF-8
        codes['UTF-8'] = list(encoded)  # преобразуем байты в список, так как UTF-8 может использовать несколько байтов
    except:
        codes['UTF-8'] = 'N/A'  # если возникла ошибка кодирования
    
    try:
        # Получаем код в UTF-16
        encoded = char.encode('utf-16')  # кодируем символ в UTF-16
        # Пропускаем BOM (Byte Order Mark) и берем только байты символа
        codes['UTF-16'] = list(encoded[2:])  # первые 2 байта - это BOM, остальные - сам символ
    except:
        codes['UTF-16'] = 'N/A'  # если возникла ошибка кодирования
    
    return codes  # возвращаем словарь с кодами символа

# Создаем функцию для обновления отображения информации о символе
def update_display(char, event=None):
    """
    Функция для обновления отображения информации о нажатом символе
    """
    # Обновляем метку с нажатым символом
    char_label.config(text=f"Нажатый символ: '{char}'")  # обновляем текст метки, показывая нажатый символ
    
    # Получаем коды символа в разных кодировках
    codes = get_char_codes(char)  # вызываем функцию получения кодов для данного символа
    
    # Очищаем текстовое поле
    text_area.delete('1.0', tk.END)  # удаляем весь текст из текстового поля, начиная с первой строки до конца
    
    # Добавляем заголовок
    text_area.insert(tk.END, f"Коды символа '{char}':\n")  # вставляем заголовок с информацией о символе
    text_area.insert(tk.END, "=" * 50 + "\n\n")  # добавляем разделительную линию
    
    # Выводим коды в разных системах кодирования
    for encoding, code in codes.items():  # проходим по всем кодировкам и их кодам в словаре
        if encoding == 'Unicode (UTF-32)':  # для Unicode выводим дополнительную информацию
            text_area.insert(tk.END, f"{encoding}:\n")  # вставляем название кодировки
            text_area.insert(tk.END, f"  Десятичный: {code}\n")  # выводим код в десятичной системе
            text_area.insert(tk.END, f"  Шестнадцатеричный: 0x{code:04X}\n")  # выводим код в шестнадцатеричной системе
            text_area.insert(tk.END, f"  Двоичный: {code:016b}\n\n")  # выводим код в двоичной системе
        elif encoding in ['UTF-8', 'UTF-16']:  # для многобайтовых кодировок
            text_area.insert(tk.END, f"{encoding}:\n")  # вставляем название кодировки
            if code != 'N/A':  # если код доступен
                hex_codes = [f"0x{byte:02X}" for byte in code]  # преобразуем каждый байт в шестнадцатеричный формат
                text_area.insert(tk.END, f"  Байты: {code}\n")  # выводим байты в десятичной системе
                text_area.insert(tk.END, f"  Шестнадцатеричный: {hex_codes}\n\n")  # выводим байты в шестнадцатеричной системе
            else:
                text_area.insert(tk.END, f"  Не поддерживается\n\n")  # если символ не поддерживается
        else:  # для однобайтовых кодировок
            text_area.insert(tk.END, f"{encoding}:\n")  # вставляем название кодировки
            if code != 'N/A':  # если код доступен
                text_area.insert(tk.END, f"  Десятичный: {code}\n")  # выводим код в десятичной системе
                text_area.insert(tk.END, f"  Шестнадцатеричный: 0x{code:02X}\n")  # выводим код в шестнадцатеричной системе
                text_area.insert(tk.END, f"  Двоичный: {code:08b}\n\n")  # выводим код в двоичной системе
            else:
                text_area.insert(tk.END, f"  Не поддерживается\n\n")  # если символ не поддерживается

# Создаем функцию-обработчик нажатия клавиш
def on_key_press(event):
    """
    Функция-обработчик события нажатия клавиши
    """
    # Проверяем, является ли нажатая клавиша символьной (а не управляющей)
    if len(event.char) > 0 and event.char != '':  # если символ не пустой (не управляющая клавиша)
        update_display(event.char, event)  # вызываем функцию обновления отображения с переданным символом
    else:
        # Для управляющих клавиш выводим специальное сообщение
        char_label.config(text=f"Нажата управляющая клавиша: {event.keysym}")  # показываем название управляющей клавиши
        text_area.delete('1.0', tk.END)  # очищаем текстовое поле
        text_area.insert(tk.END, "Управляющие клавиши (Enter, Shift, Ctrl, Alt и т.д.)\n")  # выводим сообщение
        text_area.insert(tk.END, "не имеют символьного представления в кодировках.\n")  # объясняем причину
        text_area.insert(tk.END, "Нажмите букву, цифру или символ для получения кодов.")  # предлагаем действие

# Создаем словарь с ASCII кодами для основных символов
ascii_codes = {}  # создаем пустой словарь для ASCII кодов
for i in range(32, 127):  # цикл по всем символам ASCII (от 32 до 126)
    ascii_codes[chr(i)] = i  # добавляем в словарь символ и его код

# Создаем интерфейс

# Создаем метку для отображения нажатого символа
char_label = tk.Label(root, text="Нажмите любую клавишу...", font=('Arial', 14, 'bold'))  # создаем метку с инструкцией
char_label.pack(pady=20)  # размещаем метку с отступами

# Создаем фрейм для текстового поля с прокруткой
frame = tk.Frame(root)  # создаем контейнер для текстового поля и scrollbar
frame.pack(pady=10, padx=20, fill=tk.BOTH, expand=True)  # размещаем контейнер с отступами и растягиванием

# Создаем вертикальную полосу прокрутки
scrollbar = tk.Scrollbar(frame)  # создаем scrollbar внутри фрейма
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)  # размещаем scrollbar справа, заполняя по вертикали

# Создаем текстовое поле для вывода информации
text_area = tk.Text(frame, yscrollcommand=scrollbar.set, wrap=tk.WORD,  # создаем текстовое поле с привязкой к scrollbar
                   font=('Courier New', 10), bg='#f0f0f0', padx=10, pady=10)  # устанавливаем шрифт, фон и отступы
text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)  # размещаем текстовое поле слева, растягивая на всю область

# Настраиваем scrollbar для работы с текстовым полем
scrollbar.config(command=text_area.yview)  # связываем scrollbar с текстовым полем

# Создаем метку с инструкциями
instruction_label = tk.Label(root, text="Нажимайте буквы, цифры и символы на клавиатуре для отображения их кодов", 
                            font=('Arial', 10), fg='blue')  # создаем метку с инструкциями синим цветом
instruction_label.pack(pady=10)  # размещаем метку с отступами

# Создаем метку с информацией о поддерживаемых кодировках
info_label = tk.Label(root, text="Поддерживаемые кодировки: Unicode, ASCII, Windows-1251, CP866, UTF-8, UTF-16",
                     font=('Arial', 9), fg='green')  # создаем информационную метку зеленым цветом
info_label.pack(pady=5)  # размещаем метку с отступами

# Привязываем обработчик нажатия клавиш ко всему окну
root.bind('<KeyPress>', on_key_press)  # связываем событие нажатия клавиши с функцией on_key_press

# Устанавливаем фокус на окно, чтобы оно могло получать события клавиатуры
root.focus_set()  # устанавливаем фокус на главное окно для получения событий клавиатуры

# Запускаем главный цикл обработки событий
root.mainloop()  # запускаем бесконечный цикл обработки событий tkinter